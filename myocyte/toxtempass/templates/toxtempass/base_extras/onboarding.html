  <script>
  (function () {
    var toast_tour = false;

    // ===== TOUR STATE MANAGEMENT =====
    const TOUR_PAGES = ['start', 'add_new', 'create_assay'];
    const RETURN_SELECTOR_FOR_ADD_NEW = '#id_files'; // Selector to return to on add_new after create_assay
    
    function getTourState() {
      const state = localStorage.getItem('tourState');
      return state ? JSON.parse(state) : {
        tourActive: false,
        tourStarted: false,
        currentPageIndex: 0,
        currentStepIndex: 0,
        firstVisitComplete: false
      };
    }
    
    function saveTourState(state) {
      localStorage.setItem('tourState', JSON.stringify(state));
    }
    
    function startTour() {
      const state = {
        tourActive: true,
        tourStarted: true,
        currentPageIndex: 0,
        currentStepIndex: 0,
        firstVisitComplete: false
      };
      saveTourState(state);
    }
    
    function completeTour() {
      const state = getTourState();
      state.tourActive = false;
      state.firstVisitComplete = true;
      saveTourState(state);
    }
    
    function dismissTour() {
      const state = getTourState();
      state.tourActive = false;
      saveTourState(state);
    }
    
    function updateTourProgress(pageIndex, stepIndex) {
      const state = getTourState();
      state.currentPageIndex = pageIndex;
      state.currentStepIndex = stepIndex;
      saveTourState(state);
    }
    
    function shouldAutoStartTour() {
      const state = getTourState();
      const urlName = document.body.getAttribute('data-url-name');
      // Auto-start only if: on overview page, never started tour before, and first visit not complete
      return urlName === 'start' && !state.tourStarted && !state.firstVisitComplete;
    }
    
    function shouldContinueTour() {
      const state = getTourState();
      return state.tourActive;
    }
    
    function getCurrentPageIndex() {
      const urlName = document.body.getAttribute('data-url-name');
      return TOUR_PAGES.indexOf(urlName);
    }

    function toggleOverlay(state = null) {
      let overlay = document.getElementById('onboarding-overlay');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'onboarding-overlay';
        document.body.appendChild(overlay);
      }
      if (state === null) {
        overlay.style.display = (overlay.style.display === 'none' || overlay.style.display === '') ? 'block' : 'none';
      } else if (state === 'show') {
        overlay.style.display = 'block';
      } else if (state === 'hide' || state === 'hidden') {
        overlay.style.display = 'none';
      }
    }

    function showOnboardingToasts(messages, selectors, startFromStep = 0, startFromSelector = null) {
      if (toast_tour) return;
      toast_tour = true;

      const spareClass = 'spared-element';
      const currentPageIdx = getCurrentPageIndex();

      // Ensure container exists
      let container = document.getElementById('onboarding-toasts');
      if (!container) {
        container = document.createElement('div');
        container.id = 'onboarding-toasts';
        Object.assign(container.style, {
          position: 'fixed',
          top: '0', left: '0',
          width: '100%', height: '100%',
          pointerEvents: 'none',
          zIndex: '3000',
        });
        document.body.appendChild(container);
      }
      container.innerHTML = '';

      // Build steps only for selectors that actually exist
      const steps = [];
      selectors.forEach((sel, i) => {
        const target = document.querySelector(sel);
        if (!target) {
          console.log('Onboarding: ' + sel + ' does not exist. Skipping.');
          return;
        }

        // Create toast
        const toastEl = document.createElement('div');
        toastEl.classList.add('toast', 'my-3');
        Object.assign(toastEl.style, {
          position: 'absolute',
          zIndex: '6000',
          pointerEvents: 'auto'
        });
        toastEl.setAttribute('role', 'alert');
        toastEl.setAttribute('aria-live', 'assertive');
        toastEl.setAttribute('aria-atomic', 'true');

        // Position with improved placement logic
        const rect = target.getBoundingClientRect();
        const toastWidth = 300; // approximate width of the toast element in px
        const toastHeight = 100; // approximate height of the toast element in px
        let margin = 10; // margin from viewport edges and element in px
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Adjust margin for very small viewports so toast is closer to element
        if (viewportWidth < 400) {
          margin = 5;
        }

        // Candidate positions: below, above, right, left
        const positions = [];

        // Below: horizontally centered with element, below bottom edge
        let belowLeft = rect.left + rect.width / 2 - toastWidth / 2;
        if (belowLeft < margin) belowLeft = margin;
        if (belowLeft + toastWidth + margin > viewportWidth) belowLeft = viewportWidth - toastWidth - margin;
        positions.push({
          top: rect.bottom + margin,
          left: belowLeft,
          transform: 'translate(0, 0)'
        });

        // Above: horizontally centered with element, above top edge
        let aboveLeft = rect.left + rect.width / 2 - toastWidth / 2;
        if (aboveLeft < margin) aboveLeft = margin;
        if (aboveLeft + toastWidth + margin > viewportWidth) aboveLeft = viewportWidth - toastWidth - margin;
        positions.push({
          top: rect.top - toastHeight - margin,
          left: aboveLeft,
          transform: 'translate(0, 0)'
        });

        // Right: vertically centered with element, right of right edge
        let rightTop = rect.top + rect.height / 2 - toastHeight / 2;
        if (rightTop < margin) rightTop = margin;
        if (rightTop + toastHeight + margin > viewportHeight) rightTop = viewportHeight - toastHeight - margin;
        positions.push({
          top: rightTop,
          left: rect.right + margin,
          transform: 'translate(0, 0)'
        });

        // Left: vertically centered with element, left of left edge
        let leftTop = rect.top + rect.height / 2 - toastHeight / 2;
        if (leftTop < margin) leftTop = margin;
        if (leftTop + toastHeight + margin > viewportHeight) leftTop = viewportHeight - toastHeight - margin;
        positions.push({
          top: leftTop,
          left: rect.left - toastWidth - margin,
          transform: 'translate(0, 0)'
        });

        // Function to check if position fits inside viewport
        function fitsInsideViewport(pos) {
          return (
            pos.left >= margin &&
            pos.top >= margin &&
            pos.left + toastWidth + margin <= viewportWidth &&
            pos.top + toastHeight + margin <= viewportHeight
          );
        }

        // Choose first position that fits inside viewport
        let chosenPos = positions.find(p => fitsInsideViewport(p));

        // Fallback: if none fit, place toast centered at bottom with margin
        if (!chosenPos) {
          chosenPos = {
            top: viewportHeight - toastHeight - margin,
            left: (viewportWidth - toastWidth) / 2,
            transform: 'translate(0, 0)'
          };
        }

        // Ensure bottom does not go off canvas
        if (chosenPos.top + toastHeight + margin > viewportHeight) {
          chosenPos.top = viewportHeight - toastHeight - margin;
          if (chosenPos.top < margin) {
            chosenPos.top = margin; // prevent going too high off screen
          }
        }

        // Apply chosen position
        toastEl.style.top = chosenPos.top + 'px';
        toastEl.style.left = chosenPos.left + 'px';
        toastEl.style.width = toastWidth + 'px'; // fix toast width for consistency
        toastEl.style.transform = chosenPos.transform;

        // Content
        toastEl.innerHTML = `
          <div class="toast-header">
            <strong class="me-auto">Guided Tour (${steps.length + 1}/${messages.length})</strong>
            <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
          </div>
          <div class="toast-body">${messages[i]}</div>
          <div class="toast-footer d-flex justify-content-between pe-2 pb-2 px-2">
            <button type="button" class="btn btn-outline-secondary btn-previous" aria-label="Previous">Previous</button>
            <button type="button" class="btn btn-primary" aria-label="Next">Next</button>
          </div>
        `;

        container.appendChild(toastEl);
        const toastInstance = new bootstrap.Toast(toastEl, { animation: true, autohide: false });
        steps.push({ toastInstance, toastEl, target, selector: sel });
      });

      if (steps.length === 0) {
        console.warn('Onboarding: No valid steps.');
        toast_tour = false;
        return;
      }
      
      // If startFromSelector is provided, find the corresponding step index
      let actualStartStep = startFromStep;
      if (startFromSelector) {
        const foundIndex = steps.findIndex(s => s.selector === startFromSelector);
        if (foundIndex !== -1) {
          actualStartStep = foundIndex;
        }
      }

      // Determine button text for last step based on current page
      const lastStepBtn = steps[steps.length - 1].toastEl.querySelector('.btn.btn-primary');
      if (lastStepBtn) {
        const urlName = document.body.getAttribute('data-url-name');
        if (urlName === 'create_assay') {
          // Create assay returns to add_new
          lastStepBtn.textContent = 'Return to Form';
        } else if (urlName === 'add_new') {
          // add_new is the last page in tour
          lastStepBtn.textContent = 'Finish Tour';
        } else {
          // Other pages continue to next
          lastStepBtn.textContent = 'Continue to Next Page';
        }
      }

      let currentStep = actualStartStep;

      function showStep(i) {
        steps.forEach(s => {
          s.target.classList.remove(spareClass);
          s.toastInstance.hide();
        });
        const step = steps[i];
        step.target.classList.add(spareClass);
        step.toastInstance.show();
        container.style.zIndex = '7000';
        step.toastEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // Update Previous button visibility
        const prevBtn = step.toastEl.querySelector('.btn-previous');
        if (prevBtn) {
          if (i === 0) {
            prevBtn.style.display = 'none';
          } else {
            prevBtn.style.display = 'block';
          }
        }
      }

      // Wire "Previous" and "Next" buttons
      steps.forEach((step, idx) => {
        // Previous button handler
        const prevBtn = step.toastEl.querySelector('.btn-previous');
        if (prevBtn) {
          prevBtn.addEventListener('click', () => {
            if (idx > 0) {
              currentStep = idx - 1;
              updateTourProgress(currentPageIdx, currentStep);
              showStep(currentStep);
            }
          });
        }
        
        // Next button handler
        const nextBtn = step.toastEl.querySelector('.btn.btn-primary');
        if (nextBtn) {
          nextBtn.addEventListener('click', () => {
            if (idx + 1 < steps.length) {
              // Move to next step on same page
              currentStep = idx + 1;
              updateTourProgress(currentPageIdx, currentStep);
              showStep(currentStep);
            } else {
              // Last step on this page - determine navigation
              const urlName = document.body.getAttribute('data-url-name');
              
              if (urlName === 'create_assay') {
                // Return to add_new at specific selector
                const addNewPageIdx = TOUR_PAGES.indexOf('add_new');
                updateTourProgress(addNewPageIdx, 0); // Will be adjusted by selector
                // Store the target selector in sessionStorage for next page
                sessionStorage.setItem('tourReturnSelector', RETURN_SELECTOR_FOR_ADD_NEW);
                window.location.href = '/add/';
              } else if (urlName === 'add_new') {
                // This is the final page - complete tour
                completeTour();
                step.toastInstance.hide();
                toggleOverlay('hide');
                toast_tour = false;
              } else if (urlName === 'start') {
                // Navigate from start to add_new
                const nextPageIdx = currentPageIdx + 1;
                updateTourProgress(nextPageIdx, 0);
                window.location.href = '/add/';
              }
            }
          });
        }
        
        // Handle close button (dismiss tour)
        const closeBtn = step.toastEl.querySelector('.btn-close');
        if (closeBtn) {
          closeBtn.addEventListener('click', () => {
            dismissTour();
          });
        }
        
        step.toastEl.addEventListener('hidden.bs.toast', () => {
          step.target.classList.remove(spareClass);
          const anyVisible = steps.some(s => s.toastEl.classList.contains('show'));
          if (!anyVisible) {
            toggleOverlay('hide');
            toast_tour = false;
          }
        });
      });

      toggleOverlay('show');
      showStep(currentStep);
    }

    

    window.startOnboarding = function (isManualStart = false) {
      const config = window.ToxTempConfig || {};
      const onboardingHelp = config.user_onboarding_help || {};
      const urlName = document.body.getAttribute('data-url-name');
      
      if (!urlName || !onboardingHelp[urlName] || onboardingHelp[urlName].length === 0) {
        // Show message to user that no help items registered for this page
        const existingMessage = document.getElementById('onboarding-no-help-message');
        if (!existingMessage) {
          const msgDiv = document.createElement('div');
          msgDiv.id = 'onboarding-no-help-message';
          Object.assign(msgDiv.style, {
            position: 'fixed',
            top: '20px',
            left: '50%',
            transform: 'translateX(-50%)',
            padding: '15px 25px',
            backgroundColor: '#f8d7da',
            color: '#842029',
            border: '1px solid #f5c2c7',
            borderRadius: '4px',
            zIndex: '7000',
            fontSize: '16px',
            fontWeight: 'bold',
            textAlign: 'center',
            maxWidth: '90%',
          });
          msgDiv.textContent = 'We are sorry, but for this page no help-items have been registered yet.';
          document.body.appendChild(msgDiv);
          // Automatically remove message after 5 seconds
          setTimeout(() => {
            msgDiv.remove();
          }, 5000);
        }
        return;
      }
      
      // If manually started, initialize tour from beginning
      if (isManualStart) {
        startTour();
      }
      
      // Get the current tour state to determine starting step
      const tourState = getTourState();
      const currentPageIdx = getCurrentPageIndex();
      let startStep = 0;
      let startSelector = null;
      
      // Check if we're returning from another page with a specific selector
      const returnSelector = sessionStorage.getItem('tourReturnSelector');
      if (returnSelector) {
        startSelector = returnSelector;
        sessionStorage.removeItem('tourReturnSelector');
      } else if (tourState.tourActive && currentPageIdx === tourState.currentPageIndex) {
        // If tour is active and we're on the expected page, resume from saved step
        startStep = tourState.currentStepIndex;
      }
      
      const steps = onboardingHelp[urlName];
      const selectors = steps.map(pair => pair[0]);
      const messages = steps.map(pair => pair[1]);
      showOnboardingToasts(messages, selectors, startStep, startSelector);
    };

    // Attach handler for manual start button
    function attachHelpBtnHandler() {
      const btn = document.getElementById('startOnboardingBtn');
      if (btn) {
        btn.addEventListener('click', () => {
          // Check if user offcanvas is open
          const offcanvasEl = document.getElementById('offcanvasUser');
          if (offcanvasEl && offcanvasEl.classList.contains('show')) {
            const offcanvas = bootstrap.Offcanvas.getInstance(offcanvasEl);
            if (offcanvas) {
              offcanvas.hide();
            }
          }
          window.startOnboarding(true); // true = manual start
        });
      } else {
        setTimeout(attachHelpBtnHandler, 100);
      }
    }
    
    // Auto-start or continue tour on page load
    function checkTourOnLoad() {
      if (shouldAutoStartTour()) {
        // First time user on overview page - start tour
        setTimeout(() => {
          startTour();
          window.startOnboarding(false);
        }, 500);
      } else if (shouldContinueTour()) {
        // Tour is active - continue from where we left off
        setTimeout(() => {
          window.startOnboarding(false);
        }, 500);
      }
    }
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        attachHelpBtnHandler();
        checkTourOnLoad();
      });
    } else {
      attachHelpBtnHandler();
      checkTourOnLoad();
    }
  })();
  </script>
<style>
/* Additional CSS for spared elements on overlay */
.spared-element {
  position: relative !important;
  // Raise z-index higher to help ensure highlight is below toasts
  z-index: 5800 !important;
  box-shadow: 0 0 15px 3px #007bff !important;
  border-radius: 4px;
  transition: box-shadow 0.3s ease-in-out;
}
</style>
